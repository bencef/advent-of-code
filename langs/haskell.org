#+TITLE: Haskell
#+OPTIONS: toc:nil num:nil

* Syntax
** Structure
Haskell has an indentation based syntax like python.

One expression can be divided into multiple lines, as long as subequent lines are indented deeper.
#+BEGIN_SRC haskell
  if a < 3 then "smaller" else "bigger"

  -- is the same as

  if a < 3
    then "smaller"
    else "bigger"
#+END_SRC
Also blocks can be written on one line inside curly braces and expressions separated by semicolon.
#+BEGIN_SRC haskell
  form-with-block
    expr1
    expr2
    expr3

  -- is the same as

  form-with-block { expr1 ; expr2 ; expr3 }
#+END_SRC
** Comments
Inline comments start with =--= (similar to =//= in c-like languages)

Comment blocks start with ={-= and end with =-}= (similar to =/*= and =*/= in c-like languages)
** Functions
Haskell being a functional language, functions are central parts of the language.
This means it has to be easy to define and use them.

A function call is the name of a function and the parameters separated by whitespace.
#+BEGIN_SRC haskell
  f a b c
#+END_SRC
Is equivalent to the following python code:
#+BEGIN_SRC python
  f(a, b, c)
#+END_SRC
Function names can be almost anything but there are conventions:
- Function names are camelCase
- Variants of functions are named with an apostrophe at the end (e.g., foldl and foldl')
- Functions containing only special characters in their name can be used as infix

For example =+= is just like any function and can be used in a prefix form in parenthesis:
#+BEGIN_SRC haskell
  (+) 3 5 == 3 + 5 -- True
#+END_SRC

Defining a function is just defining an equation:
#+BEGIN_SRC haskell
  square a = a * a
#+END_SRC
** Types
Haskell is a statically typed language but the compiler can figure out (most of) the type of expressions.

But we can also annotate any type with the =::= operator.
#+BEGIN_SRC haskell
  pi :: Double
  pi = 3.14159265358979323
#+END_SRC
We can also annotate just parts of an expression:
#+BEGIN_SRC haskell
  (num1 :: Int) + num2
#+END_SRC
The type of functions are annotated with =->= arrows:
#+BEGIN_SRC haskell
  square :: Double -> Double
  square x = x * x
#+END_SRC
This means that square takes a Double and returns a double.

Lists are annotated with square brackets:
=[Integer]= is the type of a list of integers.

Type parameters are annotated by lowercase letters.
#+BEGIN_SRC haskell
  f :: a -> b
#+END_SRC
is equivalent to the Java declaration:
#+BEGIN_SRC java
  static <A, B> B f(A a);
#+END_SRC
We can define our own types with the =data= keyword in the following format:
#+BEGIN_SRC haskell
  data Name = Constructor1
    | Constructor2
    | Constructor3
#+END_SRC
For example:
#+BEGIN_SRC haskell
  data Point = Point Double Double

  data Rectangle = RectTwoPoints Point Point
    | RectOrigWidthHeight Point Double Double
#+END_SRC
Type names have to begin with a capital letter and variable names have to begin with a lower case letter (or special character).
** Pattern matching
One way to define functions is to substitute actual values into (some of) their parameters.
For example the following are equivalent:
#+BEGIN_SRC haskell
  factorial 0 = 0
  factorial n = n * factorial (n-1)

  -- is equivalent to

  factorial n = if n == 0 then 0 else n * factorial (n-1)
#+END_SRC
*Note:* these implementations don't take into account negative arguments.
** if
In haskell =if= is an expression similar to the trinary operator in other languages.
#+BEGIN_SRC haskell
  if pred then expr1 else expr2
#+END_SRC
Is equvalent to
#+BEGIN_SRC python
  pred ? expr1 : expr2
#+END_SRC
in other languages.

Restrictions:
- =pred= has to be an expression with type =Bool= and =expr1= has to have the same type as =expr2=.
- The else branch cannot be omitted.
** case
The =case= _expression_ is similar to the =switch/case= construct in C-like languages.
#+BEGIN_SRC haskell
  case expr1 of
    val1 -> expr2
    val2 -> expr3
    val3 -> expr4

  -- or in one line:

  case expr1 of { val1 -> expr2 ; val2 -> expr3 ; val3 -> expr4 }
#+END_SRC
Is almost equvalent to the Java code:
#+BEGIN_SRC java
  switch (expr1) {
  case val1: return expr2;
  case val2: return expr3;
  case val3: return expr4;
  }
#+END_SRC
*Note:* In Java switch is a statement meaining it doesn't have a value
whereas in Haskell case is an expression evaluating to the value of the matched expression.
** TODO let
** TODO where
** TODO Lists
** TODO List comprehensions

* TODO Semantics
** TODO Lazyness
** TODO Pureness
** TODO Currying
